from typing import List, Tuplefrom copy import deepcopyclass Board:    def __init__(self, inputs: list, robot_place , foodList : list, butterList : list):        self.row = len(inputs)        self.col = len(inputs[0])        self.inputs = inputs        self.robot_place = robot_place        self.foodsList = foodList        self.butterList = butterListclass Node:    def __init__(self, board: Board):        self.board = board        self.nexts: List[Node] = []        self.visited = False    def is_goal(self):        return True    def produce_nexts(self):        temp_robot_place = (self.board.robot_place[0], self.board.robot_place[1])        moves = [(0, 1), (1, 0,), (0, -1), (-1, 0)]        for move in moves:            next_r_place = (temp_robot_place[0] + move[0], temp_robot_place[1] + move[1])            if isValid(self.board, next_r_place[0], next_r_place[1], move):                new_input = []                newButterList = self.board.butterList.copy()                newFoodList = self.board.foodList.copy()                for tableElement in self.board.inputs:                    updateTableElement = tableElement.copy()                    new_input.append(updateTableElement)                if next_r_place not in butterList :                     newRobotPlace =  next_r_place;                else :                    lastI = next_r_place[0] + move[0]                    lastJ = next_r_place[1] + move[1]                    newButterList.append((lastI,lastJ))                    newButterList.remove(next_r_place)                    # bug dare inja fek konam                    while (lastI, lastJ) in butterList :                        lastI = lastI+move[0]                        lastJ = lastJ+move[1]                    newButterList.append((lastI,lastJ))                    next_node = Node(Board(new_input, next_r_place, ,newButterList))                    self.nexts.append(next_node)                return Falsedef dls_rec(node: Node, limit, my_path: List[Node]):    if node.is_goal():        my_path.append(node)        return my_path    if limit <= 0:        return None    node.produce_nexts()    for a_nn in node.nexts:        result = dls_rec(a_nn, limit - 1, my_path=my_path)        if result is not None:            my_path.insert(0, a_nn)            return my_pathdef ids(start_node: Node):    max_depth = 20;    for depth in range(max_depth):        front: List[Node] = []        result = dls_rec(deepcopy(start_node), depth, front)        if result is not None and result is not False:            result.insert(0, start_node)            return result        print(f'No answer was found in {depth}')def isValid(board: Board, i, j, move):    if isIN(board, i, j) and isPassable(board, i, j, move):        return True    return Falsedef isIN(board: Board, i, j):    Row = board.row    Col = board.col    if i >= 0 and j >= 0 and i < Row and j < Col:        return True    return Falsedef isPassable(board: Board, i, j, move):    if (i, j) in foodsList:        return False    if (i, j) in butterList:        isValid(board, i + move[0], j + move[1], move)    return Trueif __name__ == '__main__':    # vooroodi gereftan    foodsList = []    butterList = []    row, col = map(int, input().split())    robot_init_place = ()    qu = []    tmp_robot_place = []    tmp_foodsList = []    tmp_butterList = []    for i in range(row):        q1 = list(input().split())        nq1 = []        for j in range(col):            if q1[j] == 'x':                nq1.append(q1[j])            elif len(q1[j]) > 1:                if q1[j][1] == 'r':                    robot_init_place = (i, j)                    robot_place = (i, j)                if q1[j][1] == 'p':                    tmp_foodsList.append((i, j))                if q1[j][1] == 'b':                    tmp_butterList.append((i, j))                nq1.append(q1[j][0])            else:                nq1.append(q1[j])        qu.append(nq1)    # end of getting input    print(qu)    print(qu[3][0])    copyFood = tmp_foodsList.copy()    copyButter = tmp_butterList.copy()    my_node = Node(Board(qu, robot_place, copyFood, copyButter))
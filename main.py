import operatorimport reimport timefrom typing import List, Tuplefrom copy import deepcopyfrom itertools import permutations'''impement puzzle solving project''''''define boolean to detect win'''WIN=False'''printing colors'''class colors:    OK = '\033[92m'  # GREEN    FAIL = '\033[91m'  # RED    RESET = '\033[0m'  # RESET COLORclass style():    BLACK = '\033[30m'    RED = '\033[41m'    GREEN = '\033[42m'    YELLOW = '\033[43m'    YELLOWF = '\033[43m'    BLUE = '\033[44m'    MAGENTA = '\033[45m'    CYAN = '\033[36m'    WHITE = '\033[47m'    UNDERLINE = '\033[4m'    RESET = '\033[0m'    bold = '\033[01m''''orint map in terminal'''def print_map(map, row, column,i):    filename = "puzzles/puzzle" + str(i) + ".txt"    time.sleep(2)    with open(filename) as f:        lines = f.readlines()    print("============================")    for mm in range(row):        x = lines[mm].split()        for k in x:            print(int(k)," ", end="")        print()    print("============================")    for sss in range(row):        for j in range(2):            column+=1            x=lines[sss].split()            for k in x:                if (int(k) == 0):                    print(colors.FAIL + style.RED + "       " + colors.RESET + style.RESET, end="")                elif (int(k)==1 ):                    print(colors.OK + style.GREEN + "       " + colors.RESET + style.RESET, end="")                print(" ",end="")            print()        print()WIN = False'''define node class with domain x y and number'''class Node:    def __init__(self, number, x, y, domain: list):        self.number = number        self.x = x        self.y = y        self.domain = domain'''read input from files '''def read_input(i):    row,column=0,0    map = []    A = []    domain = []    filename="puzzle"+str(i)+".txt"    with open(filename) as f:        lines=f.readlines()    if(i==6):        print("no answer found")    else:        row, column =[int(x) for x in lines[0].split()]        for i in range(1,row+1):            z = lines[i].split()            for s in range(len(z)):                if (z[s] == '-'):                    node = Node(2, i-1, s, [0, 1])                    domain.append(node)                else:                    node = Node(int(z[s]), i-1, s, [])                    A.append(node)                map.append(node)    return row, column, map, A, domain'''converrt 1D map to 2D and split rows to print'''def splt_row_col(map):    rows = []    for i in range(row):        rows.append([])    columns = []    for i in range(column):        columns.append([])    for nodee in map:        rows[nodee.x].append(nodee)        columns[nodee.y].append(nodee)    for i in range(row):        rows[i] = sorted(rows[i], key=lambda X: X.y)    for i in range(column):        columns[i] = sorted(columns[i], key=lambda X: X.x)    return rows, columns'''check puzzle is done'''def is_complete(map):    if len(map) == row * row:        return True    return False'''convert numbers to str'''def convert_to_str(arr):    strr = ""    for i in arr:        strr += str(i.number)    return strr'''remove domain from back traking is ok ro not'''def ok(map: list):    for node in map:        if node.domain == []:            return False    return True'''find node in domain fromits location'''def node_from_loc(x, y, myList: List[Node]) -> Node:    for node in myList:        if node.x == x and node.y == y:            return node    return None'''find node is on A or not'''def in_A(A: List[Node], my_node: Node):    for A_node in A:        if A_node.x == my_node.x and A_node.y == my_node.y:            return True    return False'''involve rows and cols'''def get_involve(myList: List[Node], my_node: Node):    row, col = splt_row_col(myList)    return convert_to_str(row[my_node.x]), convert_to_str(col[my_node.y])def new_2eqal(string: str):    return string.replace("2", "1"), string.replace("2", "0")def same_str(str1: str, str2: str):    if str1.count("2") > 0 or str2.count("2") > 0:        return False    if str1 != str2:        return False    return True'''satisfy rule 1 which we dont want same strings in row and col'''def satisfy11(q, node, D):    temp = []    temp_node = Node    rows, cols = splt_row_col(q)    my_row, my_col = get_involve(q, node)    rstr1, rstr0 = new_2eqal(my_row)    cstr1, cstr0 = new_2eqal(my_col)    if my_row.count("2") == 1:        for i in range(row):            if convert_to_str(rows[i]).count("2") == 0:                nodde = node_from_loc(node.x, my_row.index("2"), D)                dom = []                for j in nodde.domain:                    dom.append(j)                temp_node = Node(nodde.number, nodde.x, nodde.y, dom)                if convert_to_str(rows[i]) == rstr0 and 0 in node_from_loc(node.x, my_row.index("2"), D).domain:                    temp.append(temp_node)                    node_from_loc(node.x, my_row.index("2"), D).domain.remove(0)                elif convert_to_str(rows[i]) == rstr1 and 1 in node_from_loc(node.x, my_row.index("2"), D).domain:                    temp.append(temp_node)                    node_from_loc(node.x, my_row.index("2"), D).domain.remove(1)    if my_col.count("2") == 1:        for i in range(column):            if convert_to_str(cols[i]).count("2") == 0:                if my_col == cstr0 and 0 in node_from_loc(node.x, my_col.index("2"), D).domain:                    nodde = node_from_loc(my_col.index("2"), node.y, D)                    dom = []                    for j in nodde.domain:                        dom.append(j)                    temp_node = Node(nodde.number, nodde.x, nodde.y, dom)                    temp.append(temp_node)                    node_from_loc(my_col.index("2"), node.y, D).domain.remove(0)                elif my_col == cstr1 and 1 in node_from_loc(my_col.index("2"), node.y, D).domain:                    nodde = node_from_loc(node.x, my_col.index("2"), D)                    dom = []                    for j in nodde.domain:                        dom.append(j)                    temp_node = Node(nodde.number, nodde.x, nodde.y, dom)                    temp.append(temp_node)                    node_from_loc(node.x, my_col.index("2"), D).domain.remove(1)    return tempdef satisfy12(q, node, D):    temp = []    temp_node = Node    rows, cols = splt_row_col(q)    my_row, my_col = get_involve(q, node)    if my_row.count("2") == 0:        for i in range(row):            if i == node.x:                continue            if convert_to_str(rows[i]).count("2") == 1 :                str1 , str0 = new_2eqal(convert_to_str(rows[i]))                if my_row == str1 :                    nodde = node_from_loc(i , convert_to_str(rows[i]).index("2"),D)                    dom = []                    for j in nodde.domain:                        dom.append(j)                    temp_node = Node(nodde.number, nodde.x, nodde.y, dom)                    if 1 in node_from_loc(i , convert_to_str(rows[i]).index("2"),D).domain :                        temp.append(temp_node)                        node_from_loc(i , convert_to_str(rows[i]).index("2"),D).domain.remove(1)                if my_row == str0 :                    nodde = node_from_loc(i, convert_to_str(rows[i]).index("2"), D)                    dom = []                    for j in nodde.domain:                        dom.append(j)                    temp_node = Node(nodde.number, nodde.x, nodde.y, dom)                    if 0 in node_from_loc(i , convert_to_str(rows[i]).index("2"),D).domain:                        temp.append(temp_node)                        node_from_loc(i , convert_to_str(rows[i]).index("2"),D).domain.remove(0)    if my_col.count("2") == 0:        for i in range(column):            if i == node.y:                continue            if convert_to_str(cols[i]).count("2") == 1 :                str1 , str0 = new_2eqal(convert_to_str(cols[i]))                if my_col == str1 :                    nodde = node_from_loc(i, convert_to_str(cols[i]).index("2"), D)                    dom = []                    for j in nodde.domain:                        dom.append(j)                    temp_node = Node(nodde.number, nodde.x, nodde.y, dom)                    if 1 in node_from_loc(i , convert_to_str(cols[i]).index("2"),D).domain:                        temp.append(temp_node)                        node_from_loc(i, convert_to_str(cols[i]).index("2"), D).domain.remove(1)                if my_col == str0 :                    nodde =  node_from_loc(i, convert_to_str(cols[i]).index("2"), D)                    dom = []                    for j in nodde.domain:                        dom.append(j)                    temp_node = Node(nodde.number, nodde.x, nodde.y, dom)                    if 0 in node_from_loc(i , convert_to_str(cols[i]).index("2"),D).domain:                        temp.append(temp_node)                        node_from_loc(i, convert_to_str(cols[i]).index("2"), D).domain.remove(0)    return temp'''use satisfy 1 and satisfy 2 to detect row and cols completly'''def satisfy1(q, node, D):    my_row, my_col = get_involve(q, node)    temp1=satisfy11(q, node, D)    temp2=satisfy12(q, node, D)    temp=[]    for i in temp1:        for j in temp2:            if(i.x==j.x and i.y==j.y):                if(len(i.domain)>len(j.domain)):                    j.domain=i.domain                elif(len(j.domain)>len(i.domain)) :                    i.domain=j.domain                else:                    if(i.domain[0]!=j.domain[0]):                        i.domain.append(j.domain[0])                        j.domain.append(i.domain[0])    for s in temp1:        temp.append(s)    for s in temp2:        temp.append(s)    return temp'''satisfy rule 2 we dont want same number of 0 and 1 in rows and cols'''def satisfy2(q, node, D):    temp=[]    temp_node=Node    my_row, my_col = get_involve(q, node)    if my_row.count("1") == row / 2:        for i in range(row):            if my_row[i] == "2":                nodde = node_from_loc(node.x, i, D)                dom = []                for j in nodde.domain:                    dom.append(j)                temp_node = Node(nodde.number, nodde.x, nodde.y, dom)                if 1 in nodde.domain:                    temp.append(temp_node)                    nodde.domain.remove(1)    if my_col.count("1") == column / 2:        for i in range(column):            if my_col[i] == "2":                nodde = node_from_loc(i, node.y, D)                dom = []                for j in nodde.domain:                    dom.append(j)                temp_node = Node(nodde.number, nodde.x, nodde.y, dom)                if 1 in nodde.domain:                    temp.append(temp_node)                    nodde.domain.remove(1)    # if my_row.count("0") == row / 2:        for i in range(row):            if my_row[i] == "2":                nodde = node_from_loc(node.x, i, D)                dom=[]                for j in nodde.domain:                    dom.append(j)                temp_node = Node(nodde.number, nodde.x, nodde.y, dom)                if 0 in nodde.domain:                    temp.append(temp_node)                    nodde.domain.remove(0)    if my_col.count("0") == column / 2:        for i in range(column):            if my_col[i] == "2":                nodde = node_from_loc(i, node.y, D)                dom = []                for j in nodde.domain:                    dom.append(j)                temp_node = Node(nodde.number, nodde.x, nodde.y, dom)                if 0 in nodde.domain:                    temp.append(temp_node)                    nodde.domain.remove(0)    return temp'''satisfy rule three we dont want 000 and 111 in rows and cols'''def satisfy3(q,node,D):    temp = []    temp_node = Node    my_row, my_col = get_involve(q, node)    row1 = 0    row0 = 0    for i in range(1,row-1,1):        if my_row[i-1] == my_row[i+1] and  my_row[i] == "2"  and my_row[i-1] == "1":            nodde = node_from_loc(node.x, i, D)            dom = []            for j in nodde.domain:                dom.append(j)            temp_node = Node(nodde.number, nodde.x, nodde.y, dom)            if 1 in node_from_loc(node.x, i, D).domain:                temp.append(temp_node)                node_from_loc(node.x, i, D).domain.remove(1)        if my_row[i-1] == my_row[i+1] and  my_row[i] == "2"  and my_row[i-1] == "0":            nodde = node_from_loc(node.x, i, D)            dom = []            for j in nodde.domain:                dom.append(j)            temp_node = Node(nodde.number, nodde.x, nodde.y, dom)            if 0 in node_from_loc(node.x, i, D).domain:                temp.append(temp_node)                node_from_loc(node.x, i, D).domain.remove(0)    for i in range (row) :        if my_row[i] == "1":            row1 +=1            row0 = 0        elif my_row[i] == "0":            row1 = 0            row0 +=1        else:            if row1 == 2 :                nodde = node_from_loc(node.x,i,D)                dom = []                for j in nodde.domain:                    dom.append(j)                temp_node = Node(nodde.number, nodde.x, nodde.y, dom)                if 1 in node_from_loc(node.x , i ,D).domain :                    temp.append(temp_node)                    node_from_loc(node.x,i,D).domain.remove(1)            elif row0 == 2:                nodde = node_from_loc(node.x,i,D)                dom = []                for j in nodde.domain:                    dom.append(j)                temp_node = Node(nodde.number, nodde.x, nodde.y, dom)                if 0 in node_from_loc(node.x,i,D).domain :                    temp.append(temp_node)                    node_from_loc(node.x,i,D).domain.remove(0)            row1 = 0            row0 = 0    row1 = 0    row0 = 0    for i in range (row-1,-1,-1) :        if my_row[i] == "1":            row1 +=1            row0 = 0        elif my_row[i] == "0":            row1 = 0            row0 +=1        else:            if row1 == 2 :                nodde = node_from_loc(node.x,i,D)                dom = []                for j in nodde.domain:                    dom.append(j)                temp_node = Node(nodde.number, nodde.x, nodde.y, dom)                if 1 in node_from_loc(node.x , i ,D).domain :                    temp.append(temp_node)                    node_from_loc(node.x,i,D).domain.remove(1)            elif row0 == 2:                nodde = node_from_loc(node.x,i,D)                dom = []                for j in nodde.domain:                    dom.append(j)                temp_node = Node(nodde.number, nodde.x, nodde.y, dom)                if 0 in node_from_loc(node.x,i,D).domain :                    temp.append(temp_node)                    node_from_loc(node.x,i,D).domain.remove(0)            row1 = 0            row0 = 0    col1 = 0    col0 = 0    for i in range(1, column - 1, 1):        if my_col[i - 1] == my_col[i + 1] and my_col[i] == "2" and my_col[i - 1] == "1":            nodde = node_from_loc(i, node.y, D)            dom = []            for j in nodde.domain:                dom.append(j)            temp_node = Node(nodde.number, nodde.x, nodde.y, dom)            if 1 in node_from_loc(i, node.y, D).domain:                temp.append(temp_node)                node_from_loc(i, node.y, D).domain.remove(1)        if my_col[i - 1] == my_col[i + 1] and my_col[i] == "2" and my_col[i - 1] == "0":            nodde = node_from_loc(i, node.y, D)            dom = []            for j in nodde.domain:                dom.append(j)            temp_node = Node(nodde.number, nodde.x, nodde.y, dom)            if 0 in node_from_loc(i, node.y, D).domain:                temp.append(temp_node)                node_from_loc(i, node.y, D).domain.remove(0)    for i in range(column):        if my_col[i] == "1":            col1 += 1            col0 = 0        elif my_col[i] == "0":            col1 = 0            col0 += 1        else:            if col1 == 2:                if 1 in node_from_loc(i, node.y, D).domain:                    nodde = node_from_loc(i, node.y, D)                    dom = []                    for j in nodde.domain:                        dom.append(j)                    temp_node = Node(nodde.number, nodde.x, nodde.y, dom)                    temp.append(temp_node)                    node_from_loc(i, node.y, D).domain.remove(1)            elif col0 == 2:                if 0 in node_from_loc(i, node.y, D).domain:                    nodde = node_from_loc(i, node.y, D)                    dom = []                    for j in nodde.domain:                        dom.append(j)                    temp_node = Node(nodde.number, nodde.x, nodde.y, dom)                    temp.append(temp_node)                    node_from_loc(i, node.y, D).domain.remove(0)            col1 = 0            col0 = 0    col1 = 0    col0 = 0    for i in range(column - 1, -1, -1):        if my_col[i] == "1":            col1 += 1            col0 = 0        elif my_col[i] == "0":            col1 = 0            col0 += 1        else:            if col1 == 2:                if 1 in node_from_loc(i, node.y, D).domain:                    nodde = node_from_loc(i, node.y, D)                    dom = []                    for j in nodde.domain:                        dom.append(j)                    temp_node = Node(nodde.number, nodde.x, nodde.y, dom)                    temp.append(temp_node)                    node_from_loc(i, node.y, D).domain.remove(1)            elif col0 == 2:                if 0 in node_from_loc(i, node.y, D).domain:                    nodde = node_from_loc(i, node.y, D)                    dom = []                    for j in nodde.domain:                        dom.append(j)                    temp_node = Node(nodde.number, nodde.x, nodde.y, dom)                    temp.append(temp_node)                    node_from_loc(i, node.y, D).domain.remove(0)    return temp#'''use satisfy 1 to 3 to detect all rules'''def forward_checking(A, D, Node):    q = A + D    temp = []    temp_tot = []    temp1=satisfy1(q, Node, D)    temp2=satisfy2(q, Node, D)    temp3 = satisfy3(q, Node, D)    #    for i in temp1:        for j in temp2:            if (i.x == j.x and i.y == j.y):                if (len(i.domain) > len(j.domain)):                    j.domain = i.domain                elif (len(j.domain) > len(i.domain)):                    i.domain = j.domain                else:                    if (i.domain[0] != j.domain[0]):                        i.domain.append(j.domain[0])                        j.domain.append(i.domain[0])    for s in temp1:        temp.append(s)    for s in temp2:        temp.append(s)    for i in temp:        for j in temp3:            if (i.x == j.x and i.y == j.y):                if (len(i.domain) > len(j.domain)):                    j.domain = i.domain                elif (len(j.domain) > len(i.domain)):                    i.domain = j.domain                else:                    if (i.domain[0] != j.domain[0]):                        i.domain.append(j.domain[0])    #                     j.domain.append(i.domain[0])    for s in temp:        temp_tot.append(s)    for s in temp3:        temp_tot.append(s)    #    return A, D, temp_tot'''solve backtarking with mrv method use forward checking'''def back_tracking(A, var_domains):    global WIN    answer=[]    if is_complete(A):        WIN=True        return A,answer    tot_len=len(var_domains)    tot_counter=0    d = []    for s in var_domains:        d.append(s)    while( tot_counter<tot_len):        my_node=var_domains[0]        tot_counter+=1        X = my_node        z=Node(X.number,X.x,X.y,X.domain)        counter1=0        while(counter1<len(X.domain) and counter1<2):            v=X.domain[counter1]            counter1+=1            flag=False            if(X in var_domains and X not in A):                flag=True                var_domains.remove(X)                X.number = v                X.domain = []                A.append(X)            A,var_domains ,temp = forward_checking(A, var_domains, X)            if ok(var_domains):                res,answer = back_tracking(A, var_domains)                answer.append(X)                if is_complete(res):                    WIN=True                    return res,answer            else:                for x in temp:                    for s in var_domains:                        if(s.x==x.x and s.y==x.y):                            for i in x.domain:                                if(i not in s.domain):                                    s.domain.append(i)                if(flag):                    for i in z.domain:                        if(i not in X.domain):                           X.domain.append(i)                    X.number = z.number                    var_domains.append(X)                    A.remove(X)    return [],answer'''read inputs and call backtraking functions'''if __name__ == '__main__':    for i in range(7):        print(i)        print("Puzzle number :" ,i)        row, column, main_map, A, domain = read_input(i)        for nodee in A :            A , domain,temp = forward_checking(A , domain ,nodee )        b = A + domain        try:            c,answer = back_tracking(A, domain)        except:            pass        print_map(main_map,row,column,i)
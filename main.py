import operatorimport refrom typing import List, Tuplefrom copy import deepcopyfrom itertools import permutationsclass colors:    OK = '\033[92m' #GREEN    FAIL = '\033[91m' #RED    RESET = '\033[0m'  # RESET COLORclass style():    BLACK = '\033[30m'    RED = '\033[41m'    GREEN = '\033[42m'    YELLOW = '\033[43m'    YELLOWF = '\033[43m'    BLUE = '\033[44m'    MAGENTA = '\033[45m'    CYAN = '\033[36m'    WHITE = '\033[47m'    UNDERLINE = '\033[4m'    RESET = '\033[0m'    bold = '\033[01m'class Node:    def __init__(self, number, x,y , domain : list):        self.number = number        self.x=x        self.y=y        self.domain = domaindef read_input():    row,column=[int(x) for x in input("plase insert row and column : ").split()]    map=[]    A=[]    domain=[]    for i in range (row):        z=input().split()        for s in range(len(z)):            if(z[s]=='-'):                node=Node(2,i,s,[0,1])                domain.append(node)            else:                node=Node(int(z[s]),i,s,[])                A.append(node)            map.append(node)    return row,column,map,A,domaindef print_map(map,row,column):    for z in range(row):        for p in range(column):            print(map[z][p].number,end="")        print()    for i in range(row):        for j in range(2):            for k in range (column):                if(map[i][k].number==0):                    print(colors.FAIL+style.RED+"       "+colors.RESET+style.RESET,end="")                elif (map[i][k].number==1 or map[i][k].number==-1):                    print(colors.OK +style.GREEN+ "       " + colors.RESET+style.RESET, end="")            print()def MRV(map,row,column):    print("hui")def MAC(map,row,column):    print("hui")def rul1(r,c):    n = row = column    for i in range(n) :        str_row = ""        str_col = ""        for k in range (n):            str_row+=str(r[i][k].number)            str_col+=str(c[i][k].number)        if str_row.count("1") >n/2 or str_row.count("0") > n/2 \                or str_col.count("1") >n/2 or str_col.count("0") > n/2 :            print(str_row)            print(str_col)            return False    return Truedef rul2(r,c):    n = row = column    for i in range (n):        first_strR = ""        first_strC = ""        for k in range(n):            first_strR +=str(r[i][k].number)            first_strC +=str(c[i][k].number)        for j in range(i+1,n):            sec_strR = ""            sec_strC = ""            for  k in range(n):                sec_strR +=str(r[j][k].number)                sec_strC +=str(c[j][k].number)            if sec_strR == first_strR or sec_strC == first_strC  :                return False    for i in range (column):        first_str = ""        for k in range(i+1,column):            first_str += str(c[i][k].number)        for j in range(i,column):            sec_str = ""            for  k in range(column):                sec_str +=str(c[j][k].number)            if sec_str == first_str :                return False    return Truedef rul3(r,c):    for i in range(row):        number1 = 0        number0 = 0        for j in range(len(r[i])):            if r[i][j].number == 1:                number1 +=1                number0 = 0                if number1 > 2 :                    return False            elif r[i][j].number == 0:                number0 += 1                number1 = 0                if number0 > 2 :                    return False            else:                number1 = 0                number0 = 0    for i in range(column):        number1 = 0        number0 = 0        for j in range(len(c[i])):            if c[i][j].number == 1:                number1 +=1                number0 = 0                if number1 > 2 :                    return False            elif c[i][j].number == 0:                number0 += 1                number1 = 0                if number0 > 2 :                    return False            else:                number1 = 0                number0 = 0    return Truedef splt_row_col(map:list[Node]):    rows = []    for i in range (row):        rows.append([])    columns = []    for i in range (column):        columns.append([])    for nodee in map :        rows[nodee.x].append(nodee)        columns[nodee.y].append(nodee)    for i in range (row):        rows[i] = sorted(rows[i],key=lambda X: X.y)    for i in range (column):        columns[i] = sorted(columns[i],key=lambda X: X.x)    return rows , columnsdef is_complete(map:list[Node]):    if len(map) == row*row:        return True    return Falsedef convert_to_str(arr : list[Node]):    strr = ""    for i in arr:        strr +=str(i.number)    return strrdef ok(map:list[Node]):    for node in map :        if node.domain == []:            return False    return Truedef node_from_loc(x,y,myList:List[Node]) -> Node :    for node in myList:        if node.x == x and node.y == y :            return node    return Nonedef in_A(A:List[Node],my_node : Node):    for A_node in A :        if A_node.x == my_node.x and A_node.y == my_node.y:            return True    return Falsedef get_involve(myList :List[Node],my_node : Node ):    row , col = splt_row_col(myList)    return convert_to_str(row[my_node.x]) ,  convert_to_str(col[my_node.y])def new_2eqal(string:str):    return string.replace("2","1") , string.replace("2","0")def satisfy11(q,node,D):    rows, cols = splt_row_col(q)    my_row, my_col = get_involve(q, node)    rstr1, rstr0 = new_2eqal(my_row)    cstr1, cstr0 = new_2eqal(my_col)    if my_row.count("2") == 1:        for i in range(row):            if convert_to_str(rows[i]).count("2") == 0:                if my_row == rstr0 and 0 in node_from_loc(node.x,convert_to_str(rows[i]).index("2"),D).domain :                    node_from_loc(node.x,convert_to_str(rows[i]).index("2"),D).domain.remove(0)                elif my_row == rstr1 and 1 in node_from_loc(node.x,convert_to_str(rows[i]).index("2"),D).domain:                    node_from_loc(node.x,convert_to_str(rows[i]).index("2"),D).domain.remove(1)    if my_col.count("2") == 1:        for i in range(column):            if convert_to_str(cols[i]).count("2") == 0:                if my_col == cstr0 and 0 in node_from_loc(node.x,convert_to_str(cols[i]).index("2"),D).domain :                    node_from_loc(convert_to_str(cols[i]).index("2"),node.y,D).domain.remove(0)                elif my_col == cstr1 and 1 in node_from_loc(convert_to_str(cols[i]).index("2"),node.y,D).domain:                    node_from_loc(node.x,convert_to_str(cols[i]).index("2"),D).domain.remove(1)def satisfy12(q,node,D):    rows, cols = splt_row_col(q)    my_row, my_col = get_involve(q, node)    if my_row.count("2") == 0 :        for i in range(row):            pass            def satisfy1(q,node,D):    my_row, my_col = get_involve(q, node)    satisfy11(q,node,D)    satisfy12(q,node,D)def satisfy2(q,node,D):    my_row, my_col = get_involve(q, node)    if  my_row.count("1") == row/2 :        for i in range(row):            if my_row[i]=="2":                nodde = node_from_loc(node.x,i,D)                if 1 in nodde.domain:                    nodde.domain.remove(1)    if  my_col.count("1") == column/2 :        for i in range(column):            if my_col[i]=="2":                nodde = node_from_loc(i,node.y,D)                if 1 in nodde.domain:                    nodde.domain.remove(1)    if  my_row.count("0") == row/2 :        for i in range(row):            if my_row[i]=="2":                nodde = node_from_loc(node.x,i,D)                if 0 in nodde.domain:                    nodde.domain.remove(0)    if  my_col.count("0") == column/2 :        for i in range(column):            if my_col[i]=="2":                nodde = node_from_loc(i,node.y,D)                if 0 in nodde.domain:                    nodde.domain.remove(0)def same_str(str1:str,str2:str):    if str1.count("2") > 0 or str2.count("2")>0:        return False    if str1!=str2:        return False    return Truedef forward_checking(A,D,Node):    q = A + D    satisfy2(q,Node,D)    roww , wtd = splt_row_col(q)    print("---------------------------")    print()    for i in range(row):        print(convert_to_str(roww[i]))    print("---------------------------")    print()    return A , Ddef back_tracking(A:list[Node],var_domains:List[Node]) :    X = Node    if is_complete(A):        print("yes")        return A    for my_node in var_domains:        X = my_node        copyD = var_domains.copy()        copyD.remove(X)        for v in X.domain :            X.number = v            X.domain = []            new_A = A.copy()            new_A.append(X)            new_A , new_var_domains = forward_checking(new_A , copyD , X )            if  ok(new_A) :                res = back_tracking(new_A,new_var_domains)                if is_complete(res):                    print("yes")                    return res            else :                new_A.remove(X)    return []if __name__ == '__main__':    row,column,main_map,A,domain=read_input()    b = A + domain    c  = back_tracking(A,domain)    roww , coll = splt_row_col(c)    for i in range(row):        print(convert_to_str(roww[i]))    # print(is_complete(main_map))    # final_map = back_tracking([],main_map)    # print(final_map)    # print_map(final_map,row,column)
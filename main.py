import operatorimport refrom typing import List, Tuplefrom copy import deepcopyfrom itertools import permutationsclass colors:    OK = '\033[92m'  # GREEN    FAIL = '\033[91m'  # RED    RESET = '\033[0m'  # RESET COLORclass style():    BLACK = '\033[30m'    RED = '\033[41m'    GREEN = '\033[42m'    YELLOW = '\033[43m'    YELLOWF = '\033[43m'    BLUE = '\033[44m'    MAGENTA = '\033[45m'    CYAN = '\033[36m'    WHITE = '\033[47m'    UNDERLINE = '\033[4m'    RESET = '\033[0m'    bold = '\033[01m'class Node:    def __init__(self, number, x, y, domain: list):        self.number = number        self.x = x        self.y = y        self.domain = domaindef read_input():    row, column = [int(x) for x in input("plase insert row and column : ").split()]    map = []    A = []    domain = []    for i in range(row):        z = input().split()        for s in range(len(z)):            if (z[s] == '-'):                node = Node(2, i, s, [0, 1])                domain.append(node)            else:                node = Node(int(z[s]), i, s, [])                A.append(node)            map.append(node)    return row, column, map, A, domaindef print_map(map, row, column):    for z in range(row):        for p in range(column):            print(map[z][p].number, end="")        print()    for i in range(row):        for j in range(2):            for k in range(column):                if (map[i][k].number == 0):                    print(colors.FAIL + style.RED + "       " + colors.RESET + style.RESET, end="")                elif (map[i][k].number == 1 or map[i][k].number == -1):                    print(colors.OK + style.GREEN + "       " + colors.RESET + style.RESET, end="")            print()def splt_row_col(map):    rows = []    for i in range(row):        rows.append([])    columns = []    for i in range(column):        columns.append([])    for nodee in map:        rows[nodee.x].append(nodee)        columns[nodee.y].append(nodee)    for i in range(row):        rows[i] = sorted(rows[i], key=lambda X: X.y)    for i in range(column):        columns[i] = sorted(columns[i], key=lambda X: X.x)    return rows, columnsdef is_complete(map):    if len(map) == row * row:        return True    return Falsedef convert_to_str(arr):    strr = ""    for i in arr:        strr += str(i.number)    return strrdef ok(map: list):    for node in map:        if node.domain == []:            return False    return Truedef node_from_loc(x, y, myList: List[Node]) -> Node:    for node in myList:        if node.x == x and node.y == y:            return node    return Nonedef in_A(A: List[Node], my_node: Node):    for A_node in A:        if A_node.x == my_node.x and A_node.y == my_node.y:            return True    return Falsedef get_involve(myList: List[Node], my_node: Node):    row, col = splt_row_col(myList)    return convert_to_str(row[my_node.x]), convert_to_str(col[my_node.y])def new_2eqal(string: str):    return string.replace("2", "1"), string.replace("2", "0")def satisfy11(q, node, D):    temp = []    temp_node = Node    rows, cols = splt_row_col(q)    my_row, my_col = get_involve(q, node)    rstr1, rstr0 = new_2eqal(my_row)    cstr1, cstr0 = new_2eqal(my_col)    if my_row.count("2") == 1:        for i in range(row):            if convert_to_str(rows[i]).count("2") == 0:                nodde = node_from_loc(node.x, my_row.index("2"), D)                dom = []                for j in nodde.domain:                    dom.append(j)                temp_node = Node(nodde.number, nodde.x, nodde.y, dom)                if convert_to_str(rows[i]) == rstr0 and 0 in node_from_loc(node.x, my_row.index("2"), D).domain:                    temp.append(temp_node)                    node_from_loc(node.x, my_row.index("2"), D).domain.remove(0)                elif convert_to_str(rows[i]) == rstr1 and 1 in node_from_loc(node.x, my_row.index("2"), D).domain:                    temp.append(temp_node)                    node_from_loc(node.x, my_row.index("2"), D).domain.remove(1)    if my_col.count("2") == 1:        for i in range(column):            if convert_to_str(cols[i]).count("2") == 0:                if my_col == cstr0 and 0 in node_from_loc(node.x, my_col.index("2"), D).domain:                    nodde = node_from_loc(my_col.index("2"), node.y, D)                    dom = []                    for j in nodde.domain:                        dom.append(j)                    temp_node = Node(nodde.number, nodde.x, nodde.y, dom)                    temp.append(temp_node)                    node_from_loc(my_col.index("2"), node.y, D).domain.remove(0)                elif my_col == cstr1 and 1 in node_from_loc(my_col.index("2"), node.y, D).domain:                    nodde = node_from_loc(node.x, my_col.index("2"), D)                    dom = []                    for j in nodde.domain:                        dom.append(j)                    temp_node = Node(nodde.number, nodde.x, nodde.y, dom)                    temp.append(temp_node)                    node_from_loc(node.x, my_col.index("2"), D).domain.remove(1)    return tempdef satisfy12(q, node, D):    temp = []    temp_node = Node    rows, cols = splt_row_col(q)    my_row, my_col = get_involve(q, node)    if my_row.count("2") == 0:        for i in range(row):            if i == node.x:                continue            if convert_to_str(rows[i]).count("2") == 1 :                str1 , str0 = new_2eqal(convert_to_str(rows[i]))                if my_row == str1 :                    nodde = node_from_loc(i , convert_to_str(rows[i]).index("2"),D)                    dom = []                    for j in nodde.domain:                        dom.append(j)                    temp_node = Node(nodde.number, nodde.x, nodde.y, dom)                    if 1 in node_from_loc(i , convert_to_str(rows[i]).index("2"),D).domain :                        temp.append(temp_node)                        node_from_loc(i , convert_to_str(rows[i]).index("2"),D).domain.remove(1)                if my_row == str0 :                    nodde = node_from_loc(i, convert_to_str(rows[i]).index("2"), D)                    dom = []                    for j in nodde.domain:                        dom.append(j)                    temp_node = Node(nodde.number, nodde.x, nodde.y, dom)                    if 0 in node_from_loc(i , convert_to_str(rows[i]).index("2"),D).domain:                        temp.append(temp_node)                        node_from_loc(i , convert_to_str(rows[i]).index("2"),D).domain.remove(0)    if my_col.count("2") == 0:        for i in range(column):            if i == node.y:                continue            if convert_to_str(cols[i]).count("2") == 1 :                str1 , str0 = new_2eqal(convert_to_str(cols[i]))                if my_col == str1 :                    nodde = node_from_loc(i, convert_to_str(cols[i]).index("2"), D)                    dom = []                    for j in nodde.domain:                        dom.append(j)                    temp_node = Node(nodde.number, nodde.x, nodde.y, dom)                    if 1 in node_from_loc(i , convert_to_str(cols[i]).index("2"),D).domain:                        temp.append(temp_node)                        node_from_loc(i, convert_to_str(cols[i]).index("2"), D).domain.remove(1)                if my_col == str0 :                    nodde =  node_from_loc(i, convert_to_str(cols[i]).index("2"), D)                    dom = []                    for j in nodde.domain:                        dom.append(j)                    temp_node = Node(nodde.number, nodde.x, nodde.y, dom)                    if 0 in node_from_loc(i , convert_to_str(cols[i]).index("2"),D).domain:                        temp.append(temp_node)                        node_from_loc(i, convert_to_str(cols[i]).index("2"), D).domain.remove(0)    return tempdef satisfy1(q, node, D):    my_row, my_col = get_involve(q, node)    temp1=satisfy11(q, node, D)    temp2=satisfy12(q, node, D)    temp=[]    for i in temp1:        for j in temp2:            if(i.x==j.x and i.y==j.y):                if(len(i.domain)>len(j.domain)):                    j.domain=i.domain                elif(len(j.domain)>len(i.domain)) :                    i.domain=j.domain                else:                    if(i.domain[0]!=j.domain[0]):                        i.domain.append(j.domain[0])                        j.domain.append(i.domain[0])    for s in temp1:        temp.append(s)    for s in temp2:        temp.append(s)    return tempdef satisfy2(q, node, D):    temp=[]    temp_node=Node    my_row, my_col = get_involve(q, node)    if my_row.count("1") == row / 2:        for i in range(row):            if my_row[i] == "2":                nodde = node_from_loc(node.x, i, D)                dom = []                for j in nodde.domain:                    dom.append(j)                temp_node = Node(nodde.number, nodde.x, nodde.y, dom)                if 1 in nodde.domain:                    temp.append(temp_node)                    nodde.domain.remove(1)    if my_col.count("1") == column / 2:        for i in range(column):            if my_col[i] == "2":                nodde = node_from_loc(i, node.y, D)                dom = []                for j in nodde.domain:                    dom.append(j)                temp_node = Node(nodde.number, nodde.x, nodde.y, dom)                if 1 in nodde.domain:                    temp.append(temp_node)                    nodde.domain.remove(1)    if my_row.count("0") == row / 2:        for i in range(row):            if my_row[i] == "2":                nodde = node_from_loc(node.x, i, D)                dom=[]                for j in nodde.domain:                    dom.append(j)                temp_node = Node(nodde.number, nodde.x, nodde.y, dom)                if 0 in nodde.domain:                    temp.append(temp_node)                    nodde.domain.remove(0)    if my_col.count("0") == column / 2:        for i in range(column):            if my_col[i] == "2":                nodde = node_from_loc(i, node.y, D)                dom = []                for j in nodde.domain:                    dom.append(j)                temp_node = Node(nodde.number, nodde.x, nodde.y, dom)                if 0 in nodde.domain:                    temp.append(temp_node)                    nodde.domain.remove(0)    return tempdef satisfy3(q,node,D):    my_row, my_col = get_involve(q, node)    row1 = 0    row0 = 0    for i in range(1,row-1,1):        if my_row[i-1] == my_row[i+1] and  my_row[i] == "2"  and my_row[i-1] == "1":            if 1 in node_from_loc(node.x, i, D).domain:                node_from_loc(node.x, i, D).domain.remove(1)        if my_row[i-1] == my_row[i+1] and  my_row[i] == "2"  and my_row[i-1] == "0":            if 0 in node_from_loc(node.x, i, D).domain:                node_from_loc(node.x, i, D).domain.remove(0)    for i in range (row) :        if my_row[i] == "1":            row1 +=1            row0 = 0        elif my_row[i] == "0":            row1 = 0            row0 +=1        else:            if row1 == 2 :                if 1 in node_from_loc(node.x , i ,D).domain :                    node_from_loc(node.x,i,D).domain.remove(1)            elif row0 == 2:                if 0 in node_from_loc(node.x,i,D).domain :                    node_from_loc(node.x,i,D).domain.remove(0)            row1 = 0            row0 = 0    row1 = 0    row0 = 0    for i in range (row-1,-1,-1) :        if my_row[i] == "1":            row1 +=1            row0 = 0        elif my_row[i] == "0":            row1 = 0            row0 +=1        else:            if row1 == 2 :                if 1 in node_from_loc(node.x , i ,D).domain :                    node_from_loc(node.x,i,D).domain.remove(1)            elif row0 == 2:                if 0 in node_from_loc(node.x,i,D).domain :                    node_from_loc(node.x,i,D).domain.remove(0)            row1 = 0            row0 = 0def same_str(str1: str, str2: str):    if str1.count("2") > 0 or str2.count("2") > 0:        return False    if str1 != str2:        return False    return Truedef forward_checking(A, D, Node):    q = A + D    temp=[]    temp_tot=[]    temp1=satisfy1(q, Node, D)    temp2=satisfy2(q, Node, D)    # temp3=satisfy3(q, Node, D)    for i in temp1:        for j in temp2:            if (i.x == j.x and i.y == j.y):                if (len(i.domain) > len(j.domain)):                    j.domain = i.domain                elif (len(j.domain) > len(i.domain)):                    i.domain = j.domain                else:                    if (i.domain[0] != j.domain[0]):                        i.domain.append(j.domain[0])                        j.domain.append(i.domain[0])    for s in temp1:        temp.append(s)    for s in temp2:        temp.append(s)    # for i in temp:    #     for j in temp3:    #         if (i.x == j.x and i.y == j.y):    #             if (len(i.domain) > len(j.domain)):    #                 j.domain = i.domain    #             elif (len(j.domain) > len(i.domain)):    #                 i.domain = j.domain    #             else:    #                 if (i.domain[0] != j.domain[0]):    #                     i.domain.append(j.domain[0])    #                     j.domain.append(i.domain[0])    for s in temp:        temp_tot.append(s)    # for s in temp3:    #     temp_tot.append(s)    return A, D,temp_totdef back_tracking(A, var_domains):    if is_complete(A):        print("yes")        return A    # A,var_domains=check(A,var_domains)    # rows, cols = splt_row_col(A + var_domains)    # print("-----------------------")    # for i in range(row):    #     print(convert_to_str(rows[i]))    # print("-----------------------")    d=[]    for x in var_domains:        d.append(x)    for my_node in var_domains:        X = my_node        z=Node(X.number,X.x,X.y,X.domain)        for v in X.domain:            d.remove(X)            X.number = v            X.domain = []            A.append(X)            A,d ,temp = forward_checking(A, d, X)            rows , cols = splt_row_col(A+d)            print("-----------------------")            for i in range (row):                print(convert_to_str(rows[i]))            print("-----------------------")            if ok(d):                print("hellloooo")                res = back_tracking(A, d)                if is_complete(res):                    print("yes")                    return res            else:                for x in temp:                    for s in d:                        if(s.x==x.x and s.y==x.y):                            s.domain=x.domain                A.remove(X)                X.domain=z.domain                X.number=z.number                d.append(X)    return []if __name__ == '__main__':    row, column, main_map, A, domain = read_input()    for nodee in A :        A , domain,temp = forward_checking(A , domain ,nodee )    # b = A + domain    # for nodee in b :    #     print("===========")    #     print(nodee.x)    #     print(nodee.y)    #     print(nodee.number)    #     print(nodee.domain)    c = back_tracking(A, domain)    # for i in range(row):    #     print(convermplete(main_map))    # # print(is_co)